<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Async注解完成异步操作]]></title>
    <url>%2Fasync-usage-in-java.html</url>
    <content type="text"><![CDATA[本文介绍了如何使用@Async注解来完成异步操作,从而加快执行速度 配置@EnableAsync, asyncExecutor bean Appliction.java1234567891011121314151617181920212223242526@SpringBootApplication@EnableAsyncpublic class Application &#123; @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() &#123; return BuildflowUtil.getJsonConverter(); &#125; @Bean @Autowired public LibraryApiService libraryApiService(RestTemplateBuilder builder)&#123; return new LibraryApiService(builder); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Bean public Executor asyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(4); executor.setMaxPoolSize(4); executor.setQueueCapacity(500); executor.setThreadNamePrefix("Fetch podlist-"); executor.initialize(); return executor; &#125;&#125; 使用在需要异步执行的函数上添加 @Async注解, 并使得该函数返回 CompletableFuture: 12345@Asyncpublic CompletableFuture&lt;List&lt;MsaRecordVo&gt;&gt; getMsaRecord(EnvironmentDto environment, List&lt;ReleaseMsaDto&gt; msaDtos, String refUrl, int envNum) &#123; ...... return CompletableFuture.completedFuture(msaRecordVos);&#125; 将所有异步执行的函数添加到一个CompletableFutur的list中:1234List&lt;CompletableFuture&lt;List&lt;MsaRecordVo&gt;&gt;&gt; futures = new LinkedList&lt;&gt;();......// in some loop:futures.add(environmentService.getMsaRecord(environment, msaDtos, releaseRepositoryUrl, environmentNumber)); 待所有异步操作结束后, 合并结果 12345678910CompletableFuture&lt;Void&gt; allDoneFuture = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));List&lt;List&lt;MsaRecordVo&gt;&gt; results = allDoneFuture.thenApply( v -&gt; futures .stream() .map(CompletableFuture::join) .collect(Collectors.toList())).get(); msaRecordVos = results.stream().flatMap(x-&gt;x.stream()).collect(toList());]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用spring-security和jwt实现SSO和权限管理]]></title>
    <url>%2Fsso-with-spring-security-and-jwt.html</url>
    <content type="text"><![CDATA[本文介绍了如何使用spring-security和jwt实现单点登录以及权限管理 what is jwtintroducion: https://jwt.io/introduction/ http://blog.leapoahead.com/2015/09/06/understanding-jwt/ http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/ tips: 不要在jwt中传递敏感信息: Do not put secret information in the payload or header elements of a JWT unless it is encrypted. Do note that with signed tokens, all the information contained within the token is exposed to users or other parties, even though they are unable to change it. This means you shou ld not put secret information within the token. jwt的签名部分主要用于验证信息是否改动以及验证信息的来源: The signature is used to verify the message wasn’t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is. jwt 应用与单点登录(SSO)系统时, 其主要的用途是在payload里面传递用户信息(username, role等) spring security用法: WebSecurityConfig.class12345678910111213141516171819202122232425262728293031323334353637@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private JwtAuthenticationEntryPoint unauthorizedHandler; @Bean public JwtAuthenticationTokenFilter authenticationTokenFilterBean() throws Exception &#123; return new JwtAuthenticationTokenFilter(); &#125; @Override protected void configure(HttpSecurity httpSecurity) throws Exception &#123; httpSecurity .csrf().disable() .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() .authorizeRequests() .antMatchers( HttpMethod.GET, "/", "/*.html", "/favicon.ico", "/**/*.html", "/**/*.css", "/**/*.js", "/api/*" ).permitAll() .anyRequest().authenticated(); httpSecurity.addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class); &#125;&#125; spring-security 可以设置多个filter对http请求进行过滤, 后端收到所有的http请求, 首先通过filter进行过滤处理, 这里设置了一个过滤器 authenticationTokenFilterBean: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@Slf4jpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private JwtTokenUtil jwtTokenUtil; @Value("$&#123;jwt.cookie&#125;") private String tokenHead; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); final String jwtToken = getJwtTokenInCookie(cookies); if(!jwtToken.equals("")) &#123; UserDetails jwtUser = jwtTokenUtil.getJwtUserFromToken(jwtToken); String userName = jwtUser.getUsername(); log.info("checking authentication of &#123;&#125;", userName); if (userName != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123; UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(jwtUser, null, jwtUser.getAuthorities()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); log.info("authenticated user &#123;&#125;, setting security context", userName); SecurityContextHolder.getContext().setAuthentication(authentication); &#125; &#125; chain.doFilter(request,response); &#125; private String getJwtTokenInCookie(Cookie[] cookies) &#123; if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals("genius")) &#123; return cookie.getValue(); &#125; &#125; &#125; return ""; &#125;&#125; 在这个过滤器中,首先从cookie中读取jwt, 然后从中解析出用户信息, 在将用户信息set进 Security上下文中,注意, 这里必须定义一个用户类,该类实现UserDetails接口,可以专门定义一个Util类来完成从jwt中提取用户信息,再组装成用户类的工作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Componentpublic class JwtTokenUtil implements Serializable &#123; private static final String CLAIM_KEY_USERNAME = "user_name"; private static final String CLAIM_KEY_EMAIL = "email"; private static final String CLAIM_KEY_ROLE = "role"; @Value("$&#123;jwt.public-key&#125;") private String publicKeyPem; public JwtUser getJwtUserFromToken(String token) &#123; String username = null; String email = ""; String role = ""; try &#123; final JwtClaims claims = getClaimsFromToken(token); username = claims.getStringClaimValue(CLAIM_KEY_USERNAME); email = claims.getStringClaimValue(CLAIM_KEY_EMAIL); role = claims.getStringClaimValue(CLAIM_KEY_ROLE); &#125; catch (MalformedClaimException e) &#123; e.printStackTrace(); &#125; List&lt;GrantedAuthority&gt; authorities = Arrays.asList(new SimpleGrantedAuthority(role)); return new JwtUser(username, email, authorities); &#125; private JwtClaims getClaimsFromToken(String token) &#123; JwtClaims claims = null; RsaKeyUtil rsaKeyUtil = new RsaKeyUtil(); try &#123; PublicKey publicKey = rsaKeyUtil.fromPemEncoded(publicKeyPem); JwtConsumer jwtConsumer = new JwtConsumerBuilder() .setVerificationKey(publicKey) .build(); claims = jwtConsumer.processToClaims(token); &#125; catch (InvalidKeySpecException e) &#123; e.printStackTrace(); &#125; catch (JoseException e) &#123; e.printStackTrace(); &#125; catch (InvalidJwtException e) &#123; e.printStackTrace(); &#125; return claims; &#125;&#125; 最后定义一个类来处理授权异常:123456789@Component@Slf4jpublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint, Serializable &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123; log.info("JwtAuthenticationEntryPoint"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized"); &#125;&#125; 在需要权限调用的方法上指定需要的权限 1@PreAuthorize("hasAuthority('admin')") SSO with spring-security and jwtbackend: step1: 后端收到http请求, 首先经过filter step2: authenticationTokenFilterBean 从cookie中读取jwt,如果能过读取到, 设置当前的security context step3: 当调用方法时, spring-security自动对比当前security-context上下文以及method上的@PreAuthorize注解, 有权限则返回结果, 没有权限触发授权异常, 由之前设置的handler处理(一般返回401) front-end: step1: 加载页面时首先从后端拿取用户登录状态, 后端从当前的security context中拿取用户信息 123456789101112131415@RestController@RequestMapping("/api")@RequiredArgsConstructor(onConstructor = @__(&#123;@Autowired&#125;))public class UserHandler &#123; @RequestMapping(method = RequestMethod.GET, value = "/users") public String getUser() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); String userName = null; if(authentication != null &amp;&amp; authentication.getPrincipal() instanceof UserDetails) &#123; userName = ((UserDetails) authentication.getPrincipal()).getUsername(); &#125; return userName; &#125;&#125; step2: 前端在执行某个需要一定用户权限的操作时, 首先检查用户有没有登录: 若用户已登录: 直接向后端发请求, 后端会做权限认证 若用户没有登录: 将用户重定向至SSO的登录系统(同时附上app_id以及返回页面的url), 用户在登录系统登录后, 该系统将包含用户信息的jwt设在cookie中,并按指定返回页面url重定向回来, 回来后, 用户将是已登录的状态.]]></content>
      <categories>
        <category>spring</category>
        <category>spring-security</category>
      </categories>
      <tags>
        <tag>spring-security</tag>
        <tag>sso</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码回滚]]></title>
    <url>%2Fcode-roll-back-by-git.html</url>
    <content type="text"><![CDATA[本文主要介绍了git中如何对代码进行回滚和撤销 工作区的恢复如果工作区的文件改坏了, 可以从暂存区或者commit对象回滚整个工作区, 或者回滚工作区中的单个文件 从暂存区恢复checkout不指定commit对象的时候, 以暂存区(Index)为文件源恢复12git checkout -- &lt;file name&gt; #指定文件git checkout . #所有文件 从commit对象恢复checkout指定commit对象或者branch的时候, 以commit对象为文件源进行恢复 123git checkout HEAD/branch -- &lt;file name&gt; #同时回滚暂存区,指定文件名git checkout HEAD/branch . # 同时覆盖暂存区,所有文件git reset --hard # source is HEAD, 同时覆盖暂存区 ps: 注意: 使用checkout命令恢复文件的时候不要忘记使用-- &lt;file name&gt; 指定要恢复的文件, 或者使用”.“号指定恢复所有文件, 如果没有指定, 那命令等同于分支切换 从指定commit对象(branch name实际上也是commit对象)恢复文件时, 会同时恢复暂存区 git checkout 命令在指定文件和不指定文件的区别 指定文件: 不会发生分支切换, HEAD还在当前工作分支, 同时用commit对象恢复工作区和暂存区里面的指定的文件 不指定文件: 会发生分支切换, HEAD指向新的分支, 工作区和暂存区内容全部替换为新分支 ps: 特别注意: 千万不要使用 git reset &lt;commit-对象&gt; --hard 如果branch不是当前branch, 则会直接丢弃当前branch, 将HEAD和branch-name直接指向新的commit tips: 除非你完全清楚自己在做什么, 否则在使用git reset的时候, 不要指定commit对象 暂存区恢复这里的暂存区恢复是指撤销提交到暂存区的修改, 如果要同时恢复工作区和暂存区, 用上面的命令即可. 从当前commit对象恢复1git reset --&lt;file-name&gt; 这个命令对应于git add的逆向操作, 本质上是拿当前所在branch的最近一次commit对象(实际上就是修改前的文件对象)来恢复暂存区 从指定commit对象恢复这个命令感觉用的比较少, 一般情况下用上面几条就够了 1git reset &lt;指定commit&gt; -- 文件名 ps: 注意: 使用git reset命令同时指定了commit对象来恢复暂存区的时候不要忘记使用-- &lt;file name&gt; 指定要恢复的文件, 如果没有指定, 会同时移动HEAD和branch name到指定的commit对象(类似于分支切换, 但是不同点在于, 是当前分支名直接指向新的commit,而分支切换不会改变分支的指,只会移动head) 其实不指定commit对象的时候等同于使用了HEAD所指向的commit对象 透过现象看本质: (在不指定-- &lt;file name&gt;时) git reset 这个命令的本质是移动HEAD和branch-name这两个指针, 使他们指向新的commit对象, 如果这个命令没有指定commit对象, 则使用的就是当前的commit对象(因为head和branch-name都指向当前commit对象, 所以没有实际上就是没有发生移动) git reset 同时对于暂存区有一定的影响, 具体如下: --mixed (default) 在1的基础上恢复暂存区 --hard 在1的基础上恢复暂存区和工作区 --soft 在1的基础上啥也不干]]></content>
      <categories>
        <category>git</category>
        <category>code roll back</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flyway with spring-boot]]></title>
    <url>%2Fflyway-with-spring-boot.html</url>
    <content type="text"><![CDATA[本文主要介绍了如何在spring-boot中使用flyway做数据库迁移 背景: 现在需要在现有spring应用的基础上增加新的功能, 需要修改DTO, 此时数据库中的表与DTO不对应,需要删除原有数据库, 建立新的数据库, 但是因为原有数据库中已经存在了数据, 这就引出了数据迁移的问题 配置flyway在pom.xml中添加依赖以及插件pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-core&lt;/artifactId&gt; &lt;version&gt;5.0.7&lt;/version&gt;&lt;/dependency&gt; 在application.properties中添加flyway的配置1234flyway.baseline-on-migrate=trueflyway.url=jdbc:mysql://172.26.138.18:3307/Pomlint?useSSL=falseflyway.user=rootflyway.password=123456 flyway.baseline-on-migrate=true可以帮助我们初始化一个非空数据库, 创建schema_version 表(也可以自己指定表名),来进行数据库版本的管理 关闭spring ddl因为使用flyway后, 所有数据表的变更都应该由flyway来维护,包括建表, 所有应该关闭spring的ddl功能, 不使用DTO自动建表, 而使用flyway-migration, 但最好使用validate 来验证手动SQL建表与DTO是否相符 1spring.jpa.hibernate.ddl-auto=validate Migrationmigration的操作都依赖于表 schema_version , 所有的migration记录和校验都在这张表里面 Apply data migration with spring-boot当我们需要对数据表进行修改时(添加或者删除列), 可以轻松的用spring-boot来做 在项目src/main/java 下创建 db.migration包, 在该包下创建以下class文件 123456789101112package db.migration;import org.flywaydb.core.api.migration.spring.SpringJdbcMigration;import org.springframework.jdbc.core.JdbcTemplate;public class V1_1__Add_version implements SpringJdbcMigration&#123; @Override public void migrate(JdbcTemplate jdbcTemplate) throws Exception &#123; jdbcTemplate.execute("ALTER TABLE BuildConfigDto add COLUMN version date"); &#125;&#125; 注意, class文件的命名需要遵循flyway的规则. 最后,修改相应的dto, 启动spring-boot即可.]]></content>
      <categories>
        <category>java</category>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>flyway</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set mysql master-slave replication with docker]]></title>
    <url>%2Fmysql-master-slave-with-docker.html</url>
    <content type="text"><![CDATA[本文主要介绍了如何设置mysql数据库的主从复制, 其中mysql服务使用docker container master side1. 先dump原有数据库, 安全操作可以在本机上执行, 指定远程服务器的host即可 1234mysqldump -h [ip_address] -u [uname] -p db_name &gt; db_backup.sql例如:mysqldump -h172.26.131.128 -uroot -p Pomlint &gt; Pomlint_db_backup.sql 2. 在远程master主机上再起一个mysql docker container这里将配置文件直接挂载进容器中, 也可以启动容器后再进入容器修改配置 1docker run --restart=always --name pomlint-mysql-master -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /srv/mysql/master-my.cnf:/etc/mysql/my.cnf -d mysql 3. 恢复数据到新起的docker先在master机器上的docker容器中创建数据库 1create database Pomlint; 然后恢复数据到容器中(可在本地操作, 指定ip 和 port即可) 1234mysql -P [port] -h [ip_address] -u [uname] -p db_name &lt; db_backup.sql例如:mysql -P 3307 -h172.26.131.128 -uroot -p Pomlint &lt; Pomlint_db_backup.sql 4. 进入master 容器中, 修改/etc/mysql/my.cnf 文件(或者提前写好, 由外部挂载进来)my.cnf是mysql启动时加载的配置文件1234echo '[mysqld]' &gt;&gt; /etc/mysql/my.cnfecho 'server-id=1' &gt;&gt; /etc/mysql/my.cnfecho 'binlog_do_db=Pomlint' &gt;&gt; /etc/mysql/my.cnfecho 'log-bin=mysql-bin' &gt;&gt; /etc/mysql/my.cnf server-id: On the master and each slave, you must use the –server-id option to establish a unique replication ID in the range from 1 to 232 − 1. “Unique”, means that each ID must be different from every other ID in use by any other replication master or slave. For example, server-id=3. binlog_do_db: 指定要复制的数据库 log-bin Enable binary logging. 完成后退出容器, 重启容器1docker restart pomlint-mysql-master slave side1. 同样的, 先dump数据1mysqldump -h192.168.133.19 -uroot -p Pomlint &gt; Pomlint_db_backup_19.sql 2. 在远程slave主机上再起一个mysql docker container配置文件可以提前写好并挂载进去, 或者在之后启动后再进行修改1docker run --restart=always --name pomlint-mysql-slave -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /srv/mysql/slave-my.cnf:/etc/mysql/my.cnf -d mysql 3. 恢复数据到新起的docker先在slave的docker中创建数据库1create database Pomlint; 可在本地操作, 指定ip 和 port即可123mysql -P [port] -h [ip_address] -u [uname] -p db_name &lt; db_backup.sql例如:mysql -P 3307 -h192.168.133.19 -uroot -p Pomlint &lt; Pomlint_db_backup_19.sql 4. 进入slave 容器中, 修改/etc/mysql/my.cnf 文件1docker exec -it pomlint-mysql-slave bash 1234echo '[mysqld]' &gt;&gt; /etc/mysql/my.cnfecho 'server-id=2' &gt;&gt; /etc/mysql/my.cnfecho 'binlog_do_db=Pomlint' &gt;&gt; /etc/mysql/my.cnfecho 'read_only=on' &gt;&gt; /etc/mysql/my.cnf 完成后退出容器, 重启容器 1docker restart pomlint-mysql-slave 配置复制操作1. 进入master容器, 再进入mysql终端1docker exec -it pomlint-mysql-master bash 1mysql -uroot -p 执行以下SQL语句123# 创建一个用户名为repl密码为123456的用户, %表示省略用户名的主机部分CREATE USER 'repl'@'%' IDENTIFIED BY '123456'; 1234# SELECT : Enable use of SELECT. Levels: Global, database, table, column.# REPLICATION SLAVE: Enable replication slaves to read binary log events from the master. Level: Global.# 给 repl账户SELECT和读取binary log events(用于复制)的权限GRANT SELECT,REPLICATION SLAVE ON *.* TO 'repl'@'%'; 12FLUSH TABLES WITH READ LOCK;SHOW MASTER STATUS; 记住表格中的两个值 FILE 和 POSITION File Position Binlog_Do_DB Binlog_Ignore_DB Executed_Gtid_Set mysql-bin.000001 603 Pomlint - - 2. 进入slave容器, 再进入mysql终端执行以下SQL语句1CHANGE MASTER TO MASTER_HOST='172.26.131.128',MASTER_PORT=3307, MASTER_USER='repl', MASTER_PASSWORD='123456', MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=603; 注意 MASTER_LOG_FILE 和 MASTER_LOG_POS 来自之前的记录值 if you specify the MASTER_HOST or MASTER_PORT option, the slave assumes that the master server is different from before (even if the option value is the same as its current value.) In this case, the old values for the master binary log file name and position are considered no longer applicable, so if you do not specify MASTER_LOG_FILE and MASTER_LOG_POS in the statement, MASTER_LOG_FILE=’’ and MASTER_LOG_POS=4 are silently appended to it. 3. 进入master MYSQL终端 unlock table1UNLOCK TABLES; 4. 进入slave MYSQL终端, 开启slave12START SLAVE;SHOW SLAVE STATUS\G]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I love Wu Xiaying !]]></title>
    <url>%2Ftrue-love.html</url>
    <content type="text"><![CDATA[To Wu Xiaying:You are my today and all of my tomorrows.And it’s as if I never really even knew love until right now, in this moment, with you.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
